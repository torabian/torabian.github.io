"use strict";(self.webpackChunktorabian_github_io=self.webpackChunktorabian_github_io||[]).push([[917],{6738:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"type":"mdx","permalink":"/workshop/standard-react-native-list","source":"@site/src/pages/workshop/standard-react-native-list.mdx","title":"ATS-01 Standard for React Native List based projects","description":"ATS-01 is a set of rules, which will be granted into any list, if it meets certain level of the conditions.","frontMatter":{"title":"ATS-01 Standard for React Native List based projects","author":"Ali Torabi","excerpt":"Set of rules to follow and check against for high quality, low maintenance react native lists screens. By implementing these rules, you make sure every screen in your app has a good UI experience for the user.","lang":"en"},"unlisted":false}');var r=n(4848),s=n(8453);const a={title:"ATS-01 Standard for React Native List based projects",author:"Ali Torabi",excerpt:"Set of rules to follow and check against for high quality, low maintenance react native lists screens. By implementing these rules, you make sure every screen in your app has a good UI experience for the user.",lang:"en"},o=void 0,l={},c=[{value:"Why the lists are important?",id:"why-the-lists-are-important",level:2},{value:"Conditions to meet ATS-01",id:"conditions-to-meet-ats-01",level:2},{value:"Only in React Native framework",id:"only-in-react-native-framework",level:3},{value:"By FlatList or other virtual list",id:"by-flatlist-or-other-virtual-list",level:3},{value:"Error handling for first-fetch strategy",id:"error-handling-for-first-fetch-strategy",level:3},{value:"Error handling when a set of data is present to the user",id:"error-handling-when-a-set-of-data-is-present-to-the-user",level:3},{value:"Empty list strategy",id:"empty-list-strategy",level:3},{value:"Pagination",id:"pagination",level:3},{value:"Skeleton loader",id:"skeleton-loader",level:3},{value:"Taking too long indication",id:"taking-too-long-indication",level:3},{value:"Timeout and retry mechanism",id:"timeout-and-retry-mechanism",level:3},{value:"Request cancellation on leaving the screen",id:"request-cancellation-on-leaving-the-screen",level:3}];function d(e){const t={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["ATS-01 is a set of rules, which will be granted into any list, if it meets certain level of the conditions.\nLack of quality in many products which we see, is due to missing full implementation of these rules.\n",(0,r.jsx)(t.em,{children:"You might already have this rules available in your app"})," - therefor no need to make adjustments just to use this document\nas reference."]}),"\n",(0,r.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/ZLnImRfvRC8?si=CV1R6qEF4HseXf5n",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",referrerpolicy:"strict-origin-when-cross-origin",allowfullscreen:!0}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Technologies"}),": React Native"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Programming Languages"}),": JavaScript/TypeScript"]}),"\n",(0,r.jsx)(t.h2,{id:"why-the-lists-are-important",children:"Why the lists are important?"}),"\n",(0,r.jsx)(t.p,{children:"Mobile applications are built heavily around lists. In a mobile device, user is usually swiping vertically and less often horizontally.\nThus, software companies need to focus on building better lists which interacts more smoothly."}),"\n",(0,r.jsx)(t.h2,{id:"conditions-to-meet-ats-01",children:"Conditions to meet ATS-01"}),"\n",(0,r.jsx)(t.p,{children:"Here is the interactive list of ATS-01 standard. ATS-01 is met when the screen must implement or be implemeneted:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Only in React Native framework"}),"\n",(0,r.jsx)(t.li,{children:"By FlatList or other virtual list"}),"\n",(0,r.jsx)(t.li,{children:"Error handling for first-fetch strategy"}),"\n",(0,r.jsx)(t.li,{children:"Error handling when a set of data is present to the user"}),"\n",(0,r.jsx)(t.li,{children:"Empty list strategy"}),"\n",(0,r.jsx)(t.li,{children:"Pagination"}),"\n",(0,r.jsx)(t.li,{children:"Skeleton loader"}),"\n",(0,r.jsx)(t.li,{children:"Taking too long indication"}),"\n",(0,r.jsx)(t.li,{children:"Timeout and retry mechanism"}),"\n",(0,r.jsx)(t.li,{children:"Request cancellation on leaving the screen"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"only-in-react-native-framework",children:"Only in React Native framework"}),"\n",(0,r.jsx)(t.p,{children:"The application needs to be written in React Native. Android/IOS/Ionic/Xamarin and etc are not accpted in this standard."}),"\n",(0,r.jsx)(t.h3,{id:"by-flatlist-or-other-virtual-list",children:"By FlatList or other virtual list"}),"\n",(0,r.jsxs)(t.p,{children:["Starndard only applies to screens which need to show dataset, usually from remote service or bluetooth, WIFI devices.\nIt does not apply to stationary elements, which are put in ",(0,r.jsx)(t.strong,{children:"ScrollView"})]}),"\n",(0,r.jsx)(t.p,{children:"Examples:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"List of posts"}),"\n",(0,r.jsx)(t.li,{children:"List of images"}),"\n",(0,r.jsx)(t.li,{children:"Bluetooth devices around"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"error-handling-for-first-fetch-strategy",children:"Error handling for first-fetch strategy"}),"\n",(0,r.jsx)(t.p,{children:"Screen needs to have a clear strategy, to show the errors occured while fetching information from remote, or any other\npermission issues, requirement in the first list."}),"\n",(0,r.jsx)(t.h3,{id:"error-handling-when-a-set-of-data-is-present-to-the-user",children:"Error handling when a set of data is present to the user"}),"\n",(0,r.jsx)(t.p,{children:"Screen should handle in case of subsequent failures of fetching data, or changes to parameters, and show them on top of the list,\nas header and give user clear action point to move next steps."}),"\n",(0,r.jsx)(t.h3,{id:"empty-list-strategy",children:"Empty list strategy"}),"\n",(0,r.jsxs)(t.p,{children:["Screen needs to clearly give user feedback if the remote list is empty.\n",(0,r.jsx)(t.strong,{children:"It should be different than network failures, other impediments precluding user to understand real data availabilty."})]}),"\n",(0,r.jsx)(t.h3,{id:"pagination",children:"Pagination"}),"\n",(0,r.jsxs)(t.p,{children:["The screen should load the data from it's remote based on user scroll threshold. Even if the remote source does not have such possiblity,\nyou need to make a ",(0,r.jsx)(t.code,{children:"PaginatableArray"})," out of it pass it to this component."]}),"\n",(0,r.jsx)(t.h3,{id:"skeleton-loader",children:"Skeleton loader"}),"\n",(0,r.jsx)(t.p,{children:"On the first pull, you need to have skeleton porportional to the real items implemented. User should not see a loader,\nwhile the screen is opened first time."}),"\n",(0,r.jsx)(t.h3,{id:"taking-too-long-indication",children:"Taking too long indication"}),"\n",(0,r.jsx)(t.p,{children:"In case loading of data is taking longer than usual, there should be indication of that, tell the user that they can\ncancel or retry in specific amount of time."}),"\n",(0,r.jsx)(t.h3,{id:"timeout-and-retry-mechanism",children:"Timeout and retry mechanism"}),"\n",(0,r.jsx)(t.p,{children:'It should be giving user message "Pull to retry" in case of failure in first or subsequent requests.'}),"\n",(0,r.jsx)(t.h3,{id:"request-cancellation-on-leaving-the-screen",children:"Request cancellation on leaving the screen"}),"\n",(0,r.jsx)(t.p,{children:"Screen needs to keep an strategy to clean up remote requests, BLE scanning, or any ongoing process to provide data\nin to screen, in case user tried to leave the screen."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var i=n(6540);const r={},s=i.createContext(r);function a(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);