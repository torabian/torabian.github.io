"use strict";(self.webpackChunktorabian_github_io=self.webpackChunktorabian_github_io||[]).push([[5476],{3520:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>g,contentTitle:()=>l,default:()=>y,frontMatter:()=>_,metadata:()=>t,toc:()=>p});const t=JSON.parse('{"type":"mdx","permalink":"/workshop/adc-keyboard-workshop","source":"@site/src/pages/workshop/adc-keyboard-workshop.mdx","title":"Building an ADC Keyboard on ESP32","description":"In this workshop, we are going to implement a production level ADC keyboard using ESP32, and native development","frontMatter":{},"unlisted":false}');var i=a(4848),r=a(8453);const o='#include "esp_log.h"\n#include "freertos/FreeRTOS.h"\n#include "driver/adc.h"\n\n\n#define KEY_NONE 0\n\n// --- Config struct ---\ntypedef struct {\n    int adc_channel;\n    int gpio_pin;\n    adc_bits_width_t bitwidth;\n    adc_atten_t atten;\n    int adc_unit;\n    uint32_t default_vref;\n    int wait_cycles_long_press;\n    int long_press_emit_wait;\n    int sample_count;\n    const char* log_topic;\n    \n} adc_keyboard_config_t;\n\n// --- Key range struct ---\ntypedef struct {\n    int min_mv;\n    int max_mv;\n    int key;\n} adc_key_range_t;\n\n// --- Callback type ---\ntypedef void (*key_event_cb_t)(int key);\n\n\n\n// Default configuration\nstatic const adc_keyboard_config_t default_adc_keyboard_cfg = {\n    .bitwidth = ADC_BITWIDTH_12,\n    .atten = ADC_ATTEN_DB_11,\n    .default_vref = 1100,\n    .adc_unit = ADC_UNIT_1,\n    .wait_cycles_long_press = 35,\n    .long_press_emit_wait = 200,\n    .sample_count = 10,\n    .log_topic = "ADC_KEYBOARD"\n};\n\n// Merge user config with defaults\nvoid merge_adc_keyboard_config(adc_keyboard_config_t* cfg) {\n    if (cfg->bitwidth == 0) cfg->bitwidth = default_adc_keyboard_cfg.bitwidth;\n    if (cfg->atten == 0) cfg->atten = default_adc_keyboard_cfg.atten;\n    if (cfg->default_vref == 0) cfg->default_vref = default_adc_keyboard_cfg.default_vref;\n    if (cfg->wait_cycles_long_press == 0) cfg->wait_cycles_long_press = default_adc_keyboard_cfg.wait_cycles_long_press;\n    if (cfg->long_press_emit_wait == 0) cfg->long_press_emit_wait = default_adc_keyboard_cfg.long_press_emit_wait;\n    if (cfg->sample_count == 0) cfg->sample_count = default_adc_keyboard_cfg.sample_count;\n    if (cfg->log_topic == NULL) cfg->log_topic = default_adc_keyboard_cfg.log_topic;\n}\n\n// --- Detect key from voltage using ranges ---\nint detect_key(int mv, const adc_key_range_t* ranges, int ranges_count) {\n    for (int i = 0; i < ranges_count; i++) {\n        if (mv >= ranges[i].min_mv && mv <= ranges[i].max_mv) {\n            return ranges[i].key;\n        }\n    }\n    return KEY_NONE;\n}\n\n// --- Capture current pressed key ---\nint capture_current_pressed(const adc_keyboard_config_t* cfg, const adc_key_range_t* ranges, int ranges_count) {\n    int sum = 0;\n    for (int i = 0; i < cfg->sample_count; i++) {\n        sum += adc1_get_raw(cfg->adc_channel);\n    }\n    int avg_raw = sum / cfg->sample_count;\n    return detect_key(avg_raw, ranges, ranges_count);\n}\n\n// --- Setup GPIO and ADC ---\nvoid setup_adc_keyboard(const adc_keyboard_config_t* cfg) {\n\n    merge_adc_keyboard_config(cfg);\n\n    gpio_set_direction(cfg->gpio_pin, GPIO_MODE_DISABLE);\n    gpio_set_pull_mode(cfg->gpio_pin, GPIO_FLOATING);\n\n    adc1_config_width(cfg->bitwidth);\n    adc1_config_channel_atten(cfg->adc_channel, cfg->atten);\n\n    vTaskDelay(pdMS_TO_TICKS(500));\n}\n\n// --- Main listener loop ---\nvoid ad_keyboard_event_listener_cycle(\n    const adc_keyboard_config_t* cfg,\n    const adc_key_range_t* ranges,\n    int ranges_count,\n    key_event_cb_t callback\n) {\n    int last_key = KEY_NONE;\n    int kept_same_key_cycles = 0;\n\n    ESP_LOGI(cfg->log_topic, "Starting ADC keyboard listener");\n\n    while (1) {\n        int current_key = capture_current_pressed(cfg, ranges, ranges_count);\n\n        // --- Same key held ---\n        if (last_key == current_key) {\n            if (current_key != KEY_NONE) {\n                if (kept_same_key_cycles > cfg->wait_cycles_long_press) {\n                    ESP_LOGI(cfg->log_topic, "[Long press] Key %d", current_key);\n                    callback(current_key);\n                    vTaskDelay(pdMS_TO_TICKS(cfg->long_press_emit_wait));\n\n                }\n\n                kept_same_key_cycles++;\n            } else {\n                kept_same_key_cycles = 0;\n            }\n        } \n        // --- Key state changed ---\n        else {\n            kept_same_key_cycles = 0;\n            if (current_key == KEY_NONE) {\n                ESP_LOGI(cfg->log_topic, "Key released");\n            } else if (last_key == KEY_NONE) {\n                ESP_LOGI(cfg->log_topic, "[Press] Key %d", current_key);\n                callback(current_key);\n            }\n        }\n\n        last_key = current_key;\n        vTaskDelay(pdMS_TO_TICKS(30));\n    }\n}\n',c='idf_component_register(SRCS "esp32-adc-keyboard.c"\n                    INCLUDE_DIRS "."\n                    REQUIRES driver esp_common esp_adc\n                    )\n',s='\n#include "esp_log.h"\n#include "freertos/FreeRTOS.h"\n#include "./adc-keyboard.c"\n\n\nenum adc_keys {\n    KEY_UP = 1,\n    KEY_DOWN,\n    KEY_LEFT,\n    KEY_RIGHT,\n    KEY_OK\n};\n\n\nvoid adc_keyboard_task(void *arg)\n{\n    adc_keyboard_config_t cfg = {\n        .adc_channel = ADC_CHANNEL_7,\n        .gpio_pin = GPIO_NUM_35,\n        .log_topic = "MAIN_KEYBOARD"\n    };\n\n    setup_adc_keyboard(&cfg);\n\n    void key_callback(int key) {\n        ESP_LOGI("MAIN_KEYBOARD", "Key pressed inline: %d", key);\n    }\n\n    adc_key_range_t ranges[] = {\n        {0, 100, KEY_LEFT},\n        {101, 500, KEY_UP},\n        {501, 1250, KEY_DOWN},\n        {1251, 2000, KEY_RIGHT},\n        {2001, 3200, KEY_OK},\n    };\n\n    ad_keyboard_event_listener_cycle(&cfg, ranges, sizeof(ranges)/sizeof(ranges[0]), key_callback);\n}\n\n\nvoid app_main(void)\n{\n    xTaskCreatePinnedToCore(adc_keyboard_task, "adc_keyboard_task", 2048, NULL, 5, NULL, 1);\n}\n';var d=a(1028);const _={},l="Building an ADC Keyboard on ESP32",g={},p=[{value:"Workshop video",id:"workshop-video",level:2},{value:"What is AD Keyboard?",id:"what-is-ad-keyboard",level:2},{value:"Challenges",id:"challenges",level:2},{value:"Download the workshop",id:"download-the-workshop",level:3},{value:"Dependencies",id:"dependencies",level:2},{value:"Your main code:",id:"your-main-code",level:2},{value:"Library code.",id:"library-code",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"building-an-adc-keyboard-on-esp32",children:"Building an ADC Keyboard on ESP32"})}),"\n",(0,i.jsx)(n.p,{children:"In this workshop, we are going to implement a production level ADC keyboard using ESP32, and native development\nkit - ESP IDF. Some knowledge can be transfered to Arduino, but this code works right away on ESP IDF 5 projects."}),"\n",(0,i.jsx)(n.h2,{id:"workshop-video",children:"Workshop video"}),"\n",(0,i.jsx)(n.p,{children:"You can watch also the video, which I have explained a lot of details and code here:"}),"\n",(0,i.jsx)("iframe",{width:"100%",style:{height:600},src:"https://www.youtube.com/embed/H4qN3ECmUfY?si=9SM2Ha1qt_r2BPAT",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",referrerpolicy:"strict-origin-when-cross-origin",allowfullscreen:!0}),"\n",(0,i.jsx)(n.h2,{id:"what-is-ad-keyboard",children:"What is AD Keyboard?"}),"\n",(0,i.jsx)(n.p,{children:"Ad keyboard is a 3 wire (GND, Input, Output) keypad system, often controlling 2 or more keys using the same wire.\nThe promise is simple, by placing resistors on the way of current, we make different voltages upon pressing any button.\nHence, by reading an analog gpio on a microcontroller, we can understand which key is pressed. This is interesting,\nbecause allows you to consume single gpio for many keys, vs digital input that requires 1 pin per button."}),"\n",(0,i.jsx)("img",{width:"300",src:"/workshops/esp32-adc-keyboard/main/images/adc_keyboard_1.avif"}),"\n",(0,i.jsx)(n.h2,{id:"challenges",children:"Challenges"}),"\n",(0,i.jsx)(n.p,{children:"During this experiment, I've realised few things:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'By default the keyboard I have is giving no resistence, so "unpressed" state is equal to 3.3v'}),"\n",(0,i.jsx)(n.li,{children:"The keybaord I've got, makes a 0 value on left press. This is not perfect, because if minimal starting point was 300 (on 12Bit\nmeasurement, range is 0-4096), I could detect 0 as no physical keyboard connected."}),"\n",(0,i.jsx)(n.li,{children:"You need a lot of code, to simulate long press, also preventing duplicate press events."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Overall the workshop is simple. We are connecting an ESP dev board to AD Keyboard."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"download-the-workshop",children:"Download the workshop"}),"\n",(0,i.jsx)("a",{href:"/workshops/esp32-adc-keyboard.zip",children:"esp32-adc-keyboard.zip"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"dependencies",children:"Dependencies"}),"\n",(0,i.jsxs)(n.p,{children:["You need to have such dependencies at least in your ",(0,i.jsx)(n.code,{children:"CMakeLists.txt"}),":"]}),"\n",(0,i.jsx)(d.A,{language:"c",title:"CMakeLists.txt",children:c}),"\n",(0,i.jsx)(n.h2,{id:"your-main-code",children:"Your main code:"}),"\n",(0,i.jsx)(d.A,{language:"c",title:"CMakeLists.txt",children:s}),"\n",(0,i.jsx)(n.h2,{id:"library-code",children:"Library code."}),"\n",(0,i.jsx)(n.p,{children:"Place this file alongside your project, it's kinda a library, for connecting AD Keyboard. I did not plan to publish\nit, it's easier to just put the file per project and modify if needed, than managing a library. Place this next to your main\nc file in esp idf."}),"\n",(0,i.jsx)(d.A,{language:"c",title:"adc-keyboard.c",children:o})]})}function y(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}}}]);