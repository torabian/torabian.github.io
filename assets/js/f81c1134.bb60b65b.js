"use strict";(self.webpackChunktorabian_github_io=self.webpackChunktorabian_github_io||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/7-reasons-why-Golang-is-the-best-backend-programming-language","metadata":{"permalink":"/blog/7-reasons-why-Golang-is-the-best-backend-programming-language","editUrl":"https://github.com/torabian/torabian.github.io/tree/main/packages/create-docusaurus/templates/shared/blog/7-reasons-why-Golang-is-the-best-backend-programming-language.mdx","source":"@site/blog/7-reasons-why-Golang-is-the-best-backend-programming-language.mdx","title":"7 Reasons why Golang is the best backend programming language","description":"In case you never heared Golang before, it is a staticly typed, compiled language, which is developed by google","date":"2025-10-13T20:32:31.000Z","tags":[],"readingTime":3.17,"hasTruncateMarker":false,"authors":[{"name":"Ali Torabi","key":null,"page":null}],"frontMatter":{"title":"7 Reasons why Golang is the best backend programming language","author":"Ali Torabi","excerpt":"In case you never heared Golang before, it is a staticly typed, compiled language, which is developed by google to reduce their need for C/C++ in web area. This language has some benefits over C/C++ besides seems to be true winner win I compared it to other programming languages that I\'ve worked with, such as PHP, C# and Node.js","lang":"en"},"unlisted":false,"nextItem":{"title":"ATS-01 Standard for React Native List based projects","permalink":"/blog/ats-01-standard-react-native-list"}},"content":"In case you never heared Golang before, it is a staticly typed, compiled language, which is developed by google\\nto reduce their need for C/C++ in web area. This language has some benefits over C/C++ besides seems to be true winner\\nwin I compared it to other programming languages that I\'ve worked with, such as PHP, C# and Node.js\\n\\nGolang can be compiled for major OS available out there, plus some microcontrollers using TinyGo and mobile applications,\\nusing Gomobile project. Today I am going to tell you the 8 major reasons we prefer go for our projects and clients.\\n\\n## 1. Golang has a simple syntax\\n\\nWhen you compare Golang with Java and C++, you just realize there are much lesser features in the language, No OOP,\\nand many flavors and options. In first glance all those tools seem to be handy, but for major use cases they are not needed\\nand only tend to complicated source code of a project, specially if it was borrowed or it\'s a legacy code.\\n\\nThis means faster development, and easier for new developers to learn and join the project.\\n\\n## 2. Golang produces binary files\\n\\nHell yeah. When you are writting code in Node.js or Python, you always need the installation, dependency management and deploying\\nissues because they are scripts. \\n\\nA well written Golang application, can be compiled into binary files (exe on Windows!) and it would be expected to run\\nfor next few decases, without any changes.\\n\\n## 3. High performance, small memory footprint\\n\\nWhen you write a node.js app, just in order to run it, you need to have somewhat serious mashine to run it, and right away gets a lot of memory and cpu usage\\neven for a hello world app. Golang binaries for small web applications are around 10-30 MB in a single executable file.\\n\\nComparing this to a Java web application, which right away needs 4GB of ram to run, and constantly needs hardware upgrade\\nand code maintenance while the server loads increases, might make you realize you could have better weekends writing \\nthose applications into something C-level performant.\\n\\n## 4. CommandLine and WebServer together.\\n\\nUsing golang you can create binary, which can both start a web server, as well as run in cli as a command line tool.\\nIn fact, major and long-lasting projects are simple executables, which provide command line interface to developers and\\ninclude a help for each action. \\n\\nIn large projects which have a lot of calculations, Web server is only a layer that maps requests to these binary files. Mostly,\\nthese layers and separation is not designed due to convenience of MVC frameworks, and the software assumed completely a web flow instead\\nof logic base and presentation layet.\\n\\n## 5. Signing and Notarization\\n\\nGolang is a proper binary, you can sign it\'s binaries for Windows and MacOs without any problems. In fact, bundling a node.js app\\ninto an executable file and run it next to an Electron app, caused an MVP to fail in our past.\\n\\n## 6. Different build target\\n\\nYou can create different version of your application using targetting, which gives you the option not only to market for different\\npeople, but not to distribute code which is not needed for all clients.\\n\\nIn case of creating a well built binary, (for example our FireBack product) you can bundle those into many applications and distribute it\\nseveral times.\\n\\n## 7. Golang is not that scary.\\n\\nMany people tend to prefer Python and Node.js because of their scripting simplicity, or re-use the knowledge in web development on the backend side.\\nThis tend to generate unportable projects, which usually have very short lifespan, and need constant maintanance. Learning Golang is not that hard,\\nand you can create CLI apps and Web apps much easier than you think."},{"id":"/ats-01-standard-react-native-list","metadata":{"permalink":"/blog/ats-01-standard-react-native-list","editUrl":"https://github.com/torabian/torabian.github.io/tree/main/packages/create-docusaurus/templates/shared/blog/ats-01-standard-react-native-list.mdx","source":"@site/blog/ats-01-standard-react-native-list.mdx","title":"ATS-01 Standard for React Native List based projects","description":"ATS-01 is a set of rules, which will be granted into any list, if it meets certain level of the conditions.","date":"2025-10-13T20:32:31.000Z","tags":[],"readingTime":2.65,"hasTruncateMarker":false,"authors":[{"name":"Ali Torabi","key":null,"page":null}],"frontMatter":{"title":"ATS-01 Standard for React Native List based projects","author":"Ali Torabi","excerpt":"Set of rules to follow and check against for high quality, low maintenance react native lists screens. By implementing these rules, you make sure every screen in your app has a good UI experience for the user.","lang":"en"},"unlisted":false,"prevItem":{"title":"7 Reasons why Golang is the best backend programming language","permalink":"/blog/7-reasons-why-Golang-is-the-best-backend-programming-language"},"nextItem":{"title":"Honest comparision of hybrid app vs. Native finally","permalink":"/blog/honest-comparision-of-hybrid-app-vs-native-finally"}},"content":"ATS-01 is a set of rules, which will be granted into any list, if it meets certain level of the conditions.\\nLack of quality in many products which we see, is due to missing full implementation of these rules.\\n*You might already have this rules available in your app* - therefor no need to make adjustments just to use this document\\nas reference.\\n\\n**Technologies**: React Native\\n\\n**Programming Languages**: JavaScript/TypeScript\\n\\n\\n## Why the lists are important?\\n\\nMobile applications are built heavily around lists. In a mobile device, user is usually swiping vertically and less often horizontally.\\nThus, software companies need to focus on building better lists which interacts more smoothly.\\n\\n## Conditions to meet ATS-01\\n\\nHere is the interactive list of ATS-01 standard. ATS-01 is met when the screen must implement or be implemeneted:\\n\\n* Only in React Native framework\\n* By FlatList or other virtual list\\n* Error handling for first-fetch strategy\\n* Error handling when a set of data is present to the user\\n* Empty list strategy\\n* Pagination\\n* Skeleton loader\\n* Taking too long indication\\n* Timeout and retry mechanism\\n* Request cancellation on leaving the screen\\n\\n\\n### Only in React Native framework\\n\\nThe application needs to be written in React Native. Android/IOS/Ionic/Xamarin and etc are not accpted in this standard.\\n\\n### By FlatList or other virtual list\\n\\nStarndard only applies to screens which need to show dataset, usually from remote service or bluetooth, WIFI devices.\\nIt does not apply to stationary elements, which are put in **ScrollView**\\n\\nExamples:\\n\\n- List of posts\\n- List of images\\n- Bluetooth devices around\\n\\n### Error handling for first-fetch strategy\\n\\nScreen needs to have a clear strategy, to show the errors occured while fetching information from remote, or any other\\npermission issues, requirement in the first list.\\n\\n### Error handling when a set of data is present to the user\\n\\nScreen should handle in case of subsequent failures of fetching data, or changes to parameters, and show them on top of the list,\\nas header and give user clear action point to move next steps.\\n\\n\\n### Empty list strategy\\n\\nScreen needs to clearly give user feedback if the remote list is empty.\\n**It should be different than network failures, other impediments precluding user to understand real data availabilty.**\\n\\n\\n### Pagination\\n\\nThe screen should load the data from it\'s remote based on user scroll threshold. Even if the remote source does not have such possiblity,\\nyou need to make a `PaginatableArray` out of it pass it to this component.\\n\\n### Skeleton loader\\n\\nOn the first pull, you need to have skeleton porportional to the real items implemented. User should not see a loader,\\nwhile the screen is opened first time.\\n\\n### Taking too long indication\\n\\nIn case loading of data is taking longer than usual, there should be indication of that, tell the user that they can\\ncancel or retry in specific amount of time.\\n\\n### Timeout and retry mechanism\\n\\nIt should be giving user message \\"Pull to retry\\" in case of failure in first or subsequent requests.\\n\\n### Request cancellation on leaving the screen\\n\\nScreen needs to keep an strategy to clean up remote requests, BLE scanning, or any ongoing process to provide data\\nin to screen, in case user tried to leave the screen."},{"id":"/honest-comparision-of-hybrid-app-vs-native-finally","metadata":{"permalink":"/blog/honest-comparision-of-hybrid-app-vs-native-finally","editUrl":"https://github.com/torabian/torabian.github.io/tree/main/packages/create-docusaurus/templates/shared/blog/honest-comparision-of-hybrid-app-vs-native-finally.mdx","source":"@site/blog/honest-comparision-of-hybrid-app-vs-native-finally.mdx","title":"Honest comparision of hybrid app vs. Native finally","description":"When considering the development of an app for your idea or business needs,","date":"2025-10-13T20:32:31.000Z","tags":[],"readingTime":11.25,"hasTruncateMarker":false,"authors":[{"name":"Ali Torabi","key":null,"page":null}],"frontMatter":{"title":"Honest comparision of hybrid app vs. Native finally","author":"Ali Torabi","excerpt":"Confront a pivotal question whether to pursue a hybrid or native approach, which one is good for your next application? In this complete guide, you\'ll discover all the details and hidden effects of each choice.","lang":"en","og_image":"/content/hybrid_vs_native.png"},"unlisted":false,"prevItem":{"title":"ATS-01 Standard for React Native List based projects","permalink":"/blog/ats-01-standard-react-native-list"},"nextItem":{"title":"Stop Chaos! Angular Translations Done Right Once","permalink":"/blog/stop-chaos-angular-translations-done-right"}},"content":"When considering the development of an app for your idea or business needs, \\nyou\'ll inevitably confront a pivotal question: whether to pursue a hybrid or native approach.\\nIn the internet there are many biased comparison, and after 20 years of being active in software\\nindustry and coding for many different companies, clients and projects I want to enlight\\nthis issue once for all.\\n\\n**If you want build an app, I invite you to be patient, and read this article completely which might save you years of hassle**\\n\\nFor those just beginning to contemplate app development with little knowledge of where to \\nstart, it\'s worth noting that there exist several avenues (setup, ecosystem, or development \\nframework) for building mobile apps. Some opt for the native route, utilizing \\nplatform-specific tools, while others embrace a hybrid approach, which overlays a \\nlayer enabling the use of a single codebase across multiple platforms, such as Android and iOS.\\n\\nIn this article and accompanying video, we\'ll delve into the considerations for choosing the \\noptimal approach for your next application, whether you\'re collaborating with a development \\nteam or embarking on the journey solo.\\n\\n- Understanding the distinctions between native and hybrid development\\n- How do I build cost-effective 2 native apps over other agencies\\n- Overview of tools commonly employed for Android Native, iOS Native, \\nand prevalent hybrid technologies\\n- Strategies for selecting the most suitable technology stack for your app\\n- How to start building your new app?\\n\\n\\n\\n## How do I build cost-effective 2 native apps over other agencies\\n\\nInternally, I use a large and significant project called Fireback to serve clients.\\nFireback aims to accelerate the development process for native Android and iOS apps by providing \\nseveral key features and tools. Here\'s how Fireback can expedite the creation of native apps \\ncompared to manual development:\\n\\n- **Code Generation:** Fireback offers powerful code generation tools that automate the creation of boilerplate code for Android and iOS apps. By defining the data model and business logic in a Module2 file, Fireback can generate the necessary code for models, API clients, and other components of the app.\\n- **Integrated SDKs:** Fireback provides integrated SDKs for Android and iOS that simplify the process of integrating the backend with the native apps. These SDKs handle communication with the backend API, data serialization, authentication, and other tasks, reducing the amount of manual coding required.\\n- **Standardized Architecture:** Fireback promotes a standardized architecture for native apps, ensuring consistency and maintainability across different platforms. By adhering to best practices and conventions, developers can build robust and scalable apps more efficiently.\\n- **Prebuilt Components:** Fireback includes prebuilt components and templates for common app features such as user authentication, data fetching, and UI components. Developers can leverage these components to quickly assemble the app\'s functionality without starting from scratch.\\n- **Cross-Platform Support:** While Fireback focuses on native Android and iOS development, it also supports cross-platform frameworks like React Native and Flutter. Developers can use Fireback to generate code for these frameworks, further accelerating the development process and enabling code reuse across platforms.\\n\\nOverall, Fireback streamlines the development of native Android and iOS apps by automating repetitive tasks, providing standardized solutions, and integrating seamlessly with the backend. By leveraging Fireback\'s features and tools, developers can build high-quality apps faster and more efficiently than manual development methods.\\n\\n## Understanding the distinctions between native and hybrid development\\n\\nNative and hybrid app development are two prevalent approaches for creating mobile \\napplications, each offering unique advantages and considerations. In native app development, \\ndevelopers utilize platform-specific languages and tools such as Swift for iOS and Android Java\\nfor Android to build applications tailored specifically for a single operating system. \\nThis approach maximizes performance, integration with device features, and adherence to\\nplatform guidelines, resulting in a polished user experience. On the other hand, hybrid \\napp development leverages web technologies like JavaScript, HTML, and CSS within frameworks \\nsuch as React Native, React Cordova, Flutter, and Xamarin to enable cross-platform compatibility.\\nWhile hybrid apps can expedite development and reduce costs by sharing a single \\ncodebase across multiple platforms, they may sacrifice some performance and platform-specific \\noptimizations. Each approach presents its own set of trade-offs, and the choice between \\nnative and hybrid development depends on factors such as project requirements, budget, and \\ntarget audience.\\n\\nHybrid apps, while offering cross-platform compatibility and potential cost savings in development,\\noften incur higher maintenance costs due to several factors. One significant contributor is the \\nquality of JavaScript and the hybrid framework itself. Unlike native solutions which are optimized\\nfor specific platforms, hybrid apps rely on web technologies wrapped within a framework to \\nfunction across multiple platforms. This abstraction layer can introduce performance \\ninefficiencies and compatibility issues, necessitating ongoing maintenance efforts to address \\nbugs, optimize performance, and ensure compatibility with platform updates. Consequently, \\nbusinesses opting for hybrid development should carefully consider the long-term maintenance \\nimplications and allocate resources accordingly to mitigate potential challenges and ensure the\\ncontinued success of their apps.\\n\\n### Performance:\\n- Native apps are typically faster and more responsive because they are specifically \\noptimized for the platform they are built for (iOS or Android). They have direct access \\nto device-specific features and can leverage the full potential of the device\'s hardware.\\n- Hybrid apps, on the other hand, often rely on a web view component to render their \\nuser interface, which can introduce some performance overhead compared to native apps. \\nHowever, advancements in hybrid frameworks have narrowed this performance gap significantly.\\n\\n### User Experience:\\n- Native apps provide a seamless user experience consistent with the platform\'s design guidelines.\\nThey can take advantage of native UI components and animations, resulting in a polished look and\\nfeel.\\n- Hybrid apps may not always offer the same level of user experience as native apps. \\nWhile they can mimic the appearance of native apps to some extent, they may not fully \\nreplicate the platform-specific behaviors and interactions.\\n\\n### Development Time and Cost:\\nNative app development often requires separate codebases for each platform \\n(Objective-C/Swift for iOS, Java/Kotlin for Android), which can increase development time and cost,\\nespecially if the app needs to be maintained for multiple platforms.\\nHybrid app development allows developers to write code once and deploy it across multiple platforms,\\npotentially reducing development time and cost. However, achieving feature parity across platforms \\nand optimizing performance may require additional effort.\\n\\n### Access to Device Features:\\n- Native apps have direct access to device features such as camera, GPS, accelerometer, and \\ncontacts, allowing developers to create rich, immersive experiences that leverage these \\ncapabilities.\\n- Hybrid apps can access device features through plugins or APIs provided by hybrid frameworks.\\nWhile many device features are accessible, there may be limitations or delays in implementing \\nsupport for new features compared to native development.\\n\\n\\n### Final decision for native or hybrid\\n\\nIn the long run, investing in native technologies often proves to be a more prudent choice,\\nparticularly for apps with critical functionalities requiring regular updates, or for businesses \\nheavily reliant on the quality of their applications. Native solutions offer several advantages,\\nincluding superior performance, seamless integration with platform features,\\nand access to a larger talent pool for ongoing maintenance and feature enhancements.\\nThis ensures the longevity and scalability of your app, especially if you plan to \\nestablish an in-house development team in the future.\\n\\nHowever, for those embarking on their journey or seeking to experiment with a more flexible\\napproach, a hybrid solution can still be viable. Utilizing frameworks like React Native,\\nI can assist you in building a high-quality app that balances cross-platform compatibility\\nwith performance and user experience. Whether you choose native or hybrid development, \\nmy goal remains consistent: to deliver the best possible solution tailored to your unique\\nneeds and aspirations.\\n\\n\\n## Overview of tools commonly employed for Android Native, iOS Native, and prevalent hybrid technologies\\n\\nWhile there are numerous technologies available for app development, I want to focus on the\\nmainstream here which are common (sorted from most common to least)\\n\\n## For Apple Devices (Native)\\nXcode and Swift form the backbone of iOS app development, offering a comprehensive suite of tools and resources for building native applications exclusively for Apple\'s ecosystem. Xcode serves as the integrated development environment (IDE), providing features such as code editing, debugging, and interface design. Swift, Apple\'s modern programming language, is known for its safety, performance, and ease of use. With its concise syntax and powerful features, Swift enables developers to write clean, efficient code while leveraging iOS-specific frameworks for seamless integration with device features like Touch ID, ARKit, and Core ML.\\n\\n## For Android Devices (Native)\\nAndroid Java, coupled with the Android SDK, constitutes the foundation of Android app development. Java serves as the primary programming language, offering robust support for object-oriented programming and a vast ecosystem of libraries and frameworks. The Android SDK provides tools for designing user interfaces, accessing device hardware, and managing app resources. Developers can harness the extensive capabilities of Android Java to create feature-rich applications that leverage platform-specific functionalities like notifications, background services, and deep linking.\\n\\n## React Native (Many devices)\\nReact Native revolutionizes mobile app development by enabling the creation of cross-platform applications using JavaScript and React. Leveraging a single codebase, developers can build apps for both iOS and Android platforms, saving time and resources. React Native utilizes native components under the hood, resulting in high-performance apps with native look and feel. Its hot reloading feature allows for real-time code changes, enhancing productivity during development. Additionally, the vibrant React Native community provides a wealth of third-party libraries and tools for extending functionality and solving common development challenges.\\n\\n## React.js with Webview (Cordova, Android and IOS Devices)\\nEmbedding React.js with Cordova facilitates the creation of hybrid mobile applications using web technologies like HTML, CSS, and JavaScript. Cordova acts as a bridge, enabling web applications to access native device capabilities through plugins. By embedding React.js within a Cordova project, developers can leverage the power of React\'s component-based architecture and declarative syntax to build interactive user interfaces. Cordova\'s extensive plugin ecosystem provides access to a wide range of device features, enabling developers to create hybrid apps with native-like functionality and performance.\\n\\n## Flutter (Complete new system for multiple platfroms)\\nFlutter, Google\'s UI toolkit for building natively compiled applications, enables developers to create beautiful, fast, and expressive apps for iOS, Android, and the web from a single codebase. Flutter employs Dart, a modern, object-oriented programming language, renowned for its simplicity, productivity, and performance. With Flutter\'s reactive framework and extensive widget library, developers can craft highly customizable user interfaces with smooth animations and seamless scrolling. Hot reload functionality accelerates iteration cycles, enabling rapid prototyping and iteration, while Flutter\'s rich ecosystem of packages and plugins extends functionality and enhances developer productivity.\\n\\n## Xamarin (C# developer friendly)\\nXamarin empowers developers to build cross-platform mobile applications using C# and the .NET framework. Leveraging a shared codebase, developers can target multiple platforms, including iOS, Android, and Windows, while maintaining native performance and user experience. Xamarin.Forms simplifies UI development by providing a common abstraction layer for creating user interfaces that render natively on each platform. Additionally, Xamarin\'s tight integration with Visual Studio and Xamarin Test Cloud streamlines development, debugging, and testing workflows, accelerating time to market and reducing development overhead.\\n\\n\\n### Strategies for selecting the most suitable technology stack for your app\\n\\nChoosing the appropriate framework largely depends on the individual or team and the company\'s\\ncircumstances. For instance, if you possess a proficient React Native team or a team skilled\\nin web development and aim to release a moderately critical app swiftly, React Native might \\nbe an optimal choice. Leveraging my extensive experience in React Native app development, \\ncoupled with AI code generation tools and a robust backend system, I\'ve successfully built\\napps in as little as a week, ready for store deployment.\\n\\nConversely, for established businesses prioritizing market competitiveness, availability, \\nperformance, and long-term maintenance, I recommend developing two separate native apps \\ntailored to the specific needs of their target audience. While the development pace may not \\nmatch that of a single codebase like React Native, my simultaneous work on Android and iOS \\nensures efficient development, supported by a wealth of components, experience, code generation\\ntools, and pre-solved business logics, mitigating any perceived slowdowns.\\n\\nMoreover, when teams comprise more than one individual per app, the discrepancy between \\nnative and hybrid development diminishes, particularly when utilizing the Firebase framework.\\n\\nAnother scenario where a single native app may prove more advantageous is when developing a \\ntool for installers or a stationary app for specific devices, sometimes exclusively for one \\nplatform. Maintaining a native Android or iOS app, although it may seem costlier upfront, \\nultimately proves more economical than hybrid alternatives. Additionally, native development \\ngrants greater control over intricate details, which may require extensive effort to implement \\nin hybrid systems.\\n\\n\\n## How to start building your new app?\\n\\nIf you\'re considering building an app, I\'m here to assist you in getting started. \\nFeel free to reach out to me directly at ali-torabian@outlook.com with your proposal. \\nBe sure to document your ideas thoroughly, detailing your vision for the app and explaining \\nthe underlying business concept. Let\'s connect and bring your app idea to life!\\n\\nAdditionally, if you\'re a developer venturing into mobile app development for the first time,\\nI recommend checking out https://github.com/torabian/fireback. There, you\'ll discover a \\ncomprehensive boilerplate and a suite of tools designed to expedite and streamline your \\nstartup journey, ensuring reliability and scalability without the need for frequent rewrites. \\nDive in and kickstart your mobile app development journey with confidence!"},{"id":"/stop-chaos-angular-translations-done-right","metadata":{"permalink":"/blog/stop-chaos-angular-translations-done-right","editUrl":"https://github.com/torabian/torabian.github.io/tree/main/packages/create-docusaurus/templates/shared/blog/stop-chaos-angular-translations-done-right.mdx","source":"@site/blog/stop-chaos-angular-translations-done-right.mdx","title":"Stop Chaos! Angular Translations Done Right Once","description":"Critical problems with ng translate, i18n and others","date":"2025-10-13T20:32:31.000Z","tags":[],"readingTime":6.62,"hasTruncateMarker":false,"authors":[{"name":"Ali Torabi","key":null,"page":null}],"frontMatter":{"title":"Stop Chaos! Angular Translations Done Right Once","author":"Ali Torabi","excerpt":"Have you ever had problem with translating an Angular application, and always end up with problems with keys, adding extra pipes, hardcoded translations? Get in this tutorial with me and we will solve this problem for once.","og_image":"/content/angular_translate_logo.png","lang":"en"},"unlisted":false,"prevItem":{"title":"Honest comparision of hybrid app vs. Native finally","permalink":"/blog/honest-comparision-of-hybrid-app-vs-native-finally"},"nextItem":{"title":"Stop Chaos! React & React Native Translations Done Right Once","permalink":"/blog/stop-chaos-react-and-react-native-translations-done-right"}},"content":"## Critical problems with ng translate, i18n and others\\n\\nThe significance of translations appears to be overlooked, with the second language \\noften treated as an afterthought in my projects; some even begin with non-English \\nstrings hardcoded in templates, only to encounter challenges later when attempting \\nto modify them, as the lack of type safety prevents immediate detection of all \\noccurrences, resulting in an inconsistent user experience where English words may \\nunexpectedly appear in a Spanish interface,\\nnegatively impacting the brand\'s reputation.\\n\\nThe ng translate module, while initially a convenient tool for handling translations \\nin Angular apps, often falls short in several key areas. One prevalent issue is the \\nprevalence of hardcoded strings within templates, making it challenging to maintain\\nand update translations efficiently. Additionally, the lack of IntelliSense support \\nhampers developers\' productivity, leading to potential errors and inconsistencies in \\ntranslations. Moreover, the module\'s limited capabilities for managing different \\nlanguages result in cumbersome workflows and difficulties in maintaining \\nlanguage-specific content.\\n \\nAnother significant drawback is the cumbersome process of \\nstoring translations in separate JSON files, which can lead to cluttered project \\nstructures and version control issues. These challenges collectively contribute to a \\nsuboptimal translation experience, urging developers to seek alternative solutions \\nfor their localization needs.\\n\\n## Solution is simple; And no library is needed\\n\\nIn fact, doing a bullet proof translation mechanism for Angular projects does not need\\nanother library at all. In this tutorial we are going to solve this with two items:\\n\\n- Base component for all components in the app\\n- LocaleService which will be handling changes to language and publishing it everywhere\\n\\n## What you need before\\n\\n**You can apply what you learn here to new projects, as well as your existing project**\\n\\n- In order to keep up with the training, you need an empty angular 2+ project. I am using\\nmost recent version here, which has \'standalone\' components, but if you are using older\\nversion of Angular, there would be no difference.\\n\\n- Install fireback v1.1.9 or later. You can find the binaries for different systems here: \\n<a href=\\"https://github.com/torabian/fireback/releases\\" target=\\"_blank\\">https://github.com/torabian/fireback/releases</a>https://github.com/torabian/fireback/releases for installers.\\n\\n- I use the VSCode, and Run On Save extension is enabled. You can run the translation\\nfrom CLI as well, but having this extension makes life easier by far.\\n\\n## Step 1: Verify you have access to fireback\\n\\nYou need to make sure you have access to fireback binary, either installed globally,\\nor you put it in the project directory, and ignored the file.\\n\\n## Step 2: Create the LocaleService\\n\\nHere\'s the revised version:\\n\\nThe `LocaleService` is a simple service that would be used almost everywhere in the project, \\nwith one purpose: to keep and sync the locale data.\\n\\nIn this service, there is an observable called `locale$` which we will subscribe to in \\nthe component to change the dictionary of translation variables. Additionally, there is \\na `setLocale` function to set the language. For example, `setLocale(\'en\')` would change \\nit to English.\\n\\n```ts\\nimport { Injectable } from \'@angular/core\';\\nimport { BehaviorSubject } from \'rxjs\';\\n\\n@Injectable({\\n  providedIn: \'root\',\\n})\\nexport class LocaleService {\\n  private localeSubject = new BehaviorSubject<string>(\'en\');\\n  locale$ = this.localeSubject.asObservable();\\n\\n  constructor() {}\\n\\n  setLocale(locale: string) {\\n    this.localeSubject.next(locale);\\n  }\\n}\\n```\\n\\n## Step 3: Create a base component\\n\\nCreating a base component is a powerful feature of Angular and TypeScript, \\nwhich makes it easy to extend some core features for every component in your project.\\nIf you already have such a component in your project, you can apply the code here to that. \\nIf you\'re starting fresh, create a new component called `base.component.ts`.\\n\\n**Important:** You need to use `@Directive` instead of `@Component` decorator; otherwise, \\nAngular will not compile it.\\n\\nFirstly, we need a variable, such as `s`, to hold the key translations for the template \\nor the component. It will be `protected` so that extending classes can actually access it,\\nas well as the template file.\\n\\nThen, we need to inject the `LocaleService` and an object of translation keys upon construction.\\nThis object will hold translations for all languages (as you will see later after we generate\\nthe `translations.ts` file). In this constructor, we will call a `handleLocale` function,\\nwhich is basically a subscription to the locale, and will replace the dictionary of `s`\\ncontent with the selected language.\\"\\n\\n## Step 4: Create \'strings\' folder\\n\\nHow you organize the translations is up to you, in fact. I prefer to create a `strings`\\nfolder per module and place all of their translations into that directory. \\nThis way, when I move a module folder to another project or if I want to make \\nit a library, I won\'t have to worry about the translations; they\'re already \\nsolved and attached to the component or module.\\n\\nOn the other hand, if you want to create a `strings` folder for the entire app, \\nnothing would stop you.\\n\\n## Step 5: Create strings/strings-en.yml\\n\\nIt\'s critical to keep in mind that the Fireback Language Editor module assumes English \\nas the primary language of the app. Simply put, English must be present, and other languages\\nwill be synced with keys from that one.\\n\\nNow, let\'s put the `content` inside the YAML. \\n**All translation keys must go under the `content` key**, \\notherwise they will not be considered translations.\\n\\nIf you are not familiar with YAML, think of it as JSON without quotes, and remember:\\n\\n```yaml\\ncontent:\\n  loading: Loading...\\n  done: Done :)\\n```\\n\\nIs different from the code below. (Basically intention is super important)\\n\\n```yaml\\ncontent:\\nloading: Loading...\\n  done: Done :)\\n```\\n\\nSo far, this was all the necessary steps we needed to take for translating our app.\\n\\n## Step 6: Use and config fireback language generator\\n\\nNow we need to use the Fireback language generator to simplify key generation for us.\\n\\n```bash\\nfireback gen strings --path ./src/app/components/loader-sample/strings/strings-en.yml --targets ts --langs pl,fa\\n```\\n\\nThis command will generate two additional files in the same directory:\\n`strings-pl.yml` and `strings-fa.yml`. If you open them, you will see identical \\ncontent to your `strings-en.yml`.\\n\\nAlso in the same directory, you will find a `translations.ts` file. \\nIt contains content similar to the snippet below, which has generated TypeScript \\nconstants for all three languages and exported them as `strings`.\\n\\n## Step 7: Make this automated with VSCode run-on-save\\n\\nUsing the CLI each time for building the translations is cumbersome. Therefore, we utilize the \\"Run on save\\" extension in VSCode, which you can install.\\n\\nThen, in our `settings.json` in VSCode, we need to add these rules. \\n(If you\'ve never modified this file, create a folder named `.vscode` at the root \\nof your project and add `settings.json` inside it.)\\n\\n```\\n{\\n    \\"emeraldwalk.runonsave\\": {\\n        \\"commands\\": [\\n            {\\n                \\"match\\": \\"strings-([a-z][a-z]).yml$\\",\\n                \\"cmd\\": \\"fireback gen strings --path ${file} --langs en,fa\\"\\n            }\\n        ]\\n    }\\n}\\n```\\n\\nIt would basically detect any `strings-xx.yml` change in the project, and will run strings\\ncompiler for you.\\n\\n## Step 8: Use translations\\n\\nAt this stage, we\'re essentially ready to utilize the translation file. \\nIn any component that extends from `BaseComponent`, you\'ll be able to pass `strings` and \\naccess the `s` variable both inside the component and in the template.\\n\\n\\n```ts\\nimport { Component } from \'@angular/core\';\\nimport { BaseComponent } from \'../base.component\';\\nimport { LocaleService } from \'../../locale.service\';\\nimport { strings } from \'./strings/translations\';\\n\\n@Component({\\n  selector: \'app-loader-sample\',\\n  standalone: true,\\n  imports: [],\\n  templateUrl: \'./loader-sample.component.html\',\\n  styleUrl: \'./loader-sample.component.scss\',\\n})\\nexport class LoaderSampleComponent extends BaseComponent {\\n  override s = strings;\\n  constructor(private locale: LocaleService) {\\n    super(locale, strings);\\n  }\\n}\\n```\\n\\nAnd you can access `s` and all the keys type-safely in HTML templates. *As you\'ve noticed*,\\nwe actually do not need to pipe the translations at all, and this is a significant benefit \\nboth in terms of performance and code cleanliness.\\n\\n```html\\n<p>{{ s.loading }}</p>\\n```\\n## Conclusion\\n\\nTo summarize, we have just created a robust system for adding translations to our Angular app.\\nThis method will help prevent many errors, such as missing keys in certain \\nlanguages and hard-coded strings for translation.\\n\\nThe Fireback Strings CLI offers additional options that you may want to explore on your own. \\nThis feature is available starting from Fireback v1.1.9"},{"id":"/stop-chaos-react-and-react-native-translations-done-right","metadata":{"permalink":"/blog/stop-chaos-react-and-react-native-translations-done-right","editUrl":"https://github.com/torabian/torabian.github.io/tree/main/packages/create-docusaurus/templates/shared/blog/stop-chaos-react-and-react-native-translations-done-right.mdx","source":"@site/blog/stop-chaos-react-and-react-native-translations-done-right.mdx","title":"Stop Chaos! React & React Native Translations Done Right Once","description":"Critical problems with usual react translation libraries, i18n and others","date":"2025-10-13T20:32:31.000Z","tags":[],"readingTime":6.62,"hasTruncateMarker":false,"authors":[{"name":"Ali Torabi","key":null,"page":null}],"frontMatter":{"title":"Stop Chaos! React & React Native Translations Done Right Once","author":"Ali Torabi","excerpt":"Have you ever had problem with translating an React or React Native application, and always end up with problems with keys, adding extra pipes, hardcoded translations? Get in this tutorial with me and we will solve this problem for once.","og_image":"/content/react-react-native-translation-fireback.png","lang":"en"},"unlisted":false,"prevItem":{"title":"Stop Chaos! Angular Translations Done Right Once","permalink":"/blog/stop-chaos-angular-translations-done-right"},"nextItem":{"title":"Top reasons software teams and companies suffer from their own decisions","permalink":"/blog/top-reasons-software-teams-and-companies-suffer-from-their-own-decisions"}},"content":"## Critical problems with usual react translation libraries, i18n and others\\n\\nThe significance of translations appears to be overlooked, with the second language \\noften treated as an afterthought in my projects; some even begin with non-English \\nstrings hardcoded in templates, only to encounter challenges later when attempting \\nto modify them, as the lack of type safety prevents immediate detection of all \\noccurrences, resulting in an inconsistent user experience where English words may \\nunexpectedly appear in a Spanish interface,\\nnegatively impacting the brand\'s reputation.\\n\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/-vVQ9iI2CNU?si=iRFH9tvQIrJiGkvU\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" referrerpolicy=\\"strict-origin-when-cross-origin\\" allowfullscreen></iframe>\\n\\nThe i18n module, while initially a convenient tool for handling translations \\nin React and React Native apps, often falls short in several key areas. One prevalent issue is the \\nprevalence of hardcoded strings within templates, making it challenging to maintain\\nand update translations efficiently. Additionally, the lack of IntelliSense support \\nhampers developers\' productivity, leading to potential errors and inconsistencies in \\ntranslations. Moreover, the module\'s limited capabilities for managing different \\nlanguages result in cumbersome workflows and difficulties in maintaining \\nlanguage-specific content.\\n\\n \\nAnother significant drawback is the cumbersome process of \\nstoring translations in separate JSON files, which can lead to cluttered project \\nstructures and version control issues. These challenges collectively contribute to a \\nsuboptimal translation experience, urging developers to seek alternative solutions \\nfor their localization needs.\\n\\n## Solution is simple; And no library is needed\\n\\nIn fact, doing a bullet proof translation mechanism for React and React Native projects \\ndoes not need another library at all. In this tutorial we are going to solve this with a single hook:\\n\\n- Defining `useS` hook to use a string object.\\n- Defining `useLocale` hook to keep locale settings, and also detect locale based on\\n  the user OS settings or browser settings.\\n\\n## What you need before\\n\\n**You can apply what you learn here to new projects, as well as your existing project**\\n\\n- Install fireback v1.1.9 or later. You can find the binaries for different systems here: \\n<a href=\\"https://github.com/torabian/fireback/releases\\" target=\\"_blank\\">https://github.com/torabian/fireback/releases</a> for installers\\nbinary, and you can place it inside your project folder and ignore it. **You can technically implement your own code to mimic the behavior later.**\\n\\n- I use the VSCode, and \\"Run On Save extension\\" is enabled. You can run the translation\\nfrom CLI as well, but having this extension makes life easier by far.\\n\\n## Step 1: Verify you have access to fireback\\n\\nYou need to make sure you have access to fireback binary, either installed globally,\\nor you put it in the project directory, and ignored the file.\\n\\nFireback also could be installed on npm using `npm i -D fireback-tools\'. Make sure you\\ninstall it as dev dependency, so it\'s binaries do not bundle with react native apps.\\n\\n\\n## Step 2: Create useLocale hook\\n\\n```tsx\\n\\nimport React, { createContext, useContext, useState } from \\"react\\";\\n\\ntype Locale = string; // e.g. \'en\', \'pl\', \'fr\'\\ntype LocaleContextType = {\\n  locale: Locale;\\n  setLocale: (locale: Locale) => void;\\n};\\n\\nconst LocaleContext = createContext<LocaleContextType | undefined>(undefined);\\n\\nexport const LocaleProvider = ({ children }: { children: React.ReactNode }) => {\\n  const [locale, setLocale] = useState<Locale>(\\"en\\");\\n\\n  return (\\n    <LocaleContext.Provider value={{ locale, setLocale }}>\\n      {children}\\n    </LocaleContext.Provider>\\n  );\\n};\\n\\nexport const useLocale = () => {\\n  const context = useContext(LocaleContext);\\n  if (!context) {\\n    throw new Error(\\"useLocale must be used within a LocaleProvider\\");\\n  }\\n  return context;\\n};\\n\\n```\\n\\n### Make sure you use the LocaleProvider\\n\\nIn order to get all components the correct state of the locale, make sure that the LocaleProvider is there, it could\\nlook like something:\\n\\n```tsx\\nconst AppWrapper = () => {\\n  return (\\n    <LocaleProvider>\\n      <App />\\n    </LocaleProvider>\\n  );\\n};\\n```\\n\\n## Step 3: Create the useS hook.\\n\\n```ts\\nimport { useLocale } from \\"./useLocale\\";\\n\\n// This typescript generic is important, to use strongly typed translation\\n// keys\\nexport function useS<T>(v: T): T {\\n  /*\\n   * This could be your own definition of the locale language\\n   * This variable usually should include the current language in the app\\n   * such as \'en\', or \'fa\', etc.\\n   * you might also extend it to separate the language-locale such as en-us\\n   * i haven\'t done yet due to no need\\n   */\\n  const { locale } = useLocale();\\n\\n  /*\\n   * Here we check if there lang is anything other than en, and in translation\\n   * files we have such thing with a $ prefix - which auto generated by fireback\\n   * we will access them instead. useS function will return always T,\\n   * so all the translations will be typesafe anyway from typescript compiler\\n   * perspective\\n   */\\n  if (!locale || locale === \\"en\\") {\\n    return v;\\n  } else if (!(v as any)[\\"$\\" + locale]) {\\n    return v;\\n  } else {\\n    return (v as any)[\\"$\\" + locale];\\n  }\\n}\\n```\\n\\n## Step 4: Create \'strings\' folder\\n\\nHow you organize the translations is up to you, in fact. I prefer to create a `strings`\\nfolder per module and place all of their translations into that directory. \\nThis way, when I move a module folder to another project or if I want to make \\nit a library, I won\'t have to worry about the translations; they\'re already \\nsolved and attached to the component or module.\\n\\nOn the other hand, if you want to create a `strings` folder for the entire app, \\nnothing would stop you.\\n\\n## Step 5: Create strings/strings-en.yml\\n\\nIt\'s critical to keep in mind that the Fireback Language Editor module assumes English \\nas the primary language of the app. Simply put, English must be present, and other languages\\nwill be synced with keys from that one.\\n\\nNow, let\'s put the `content` inside the YAML. \\n**All translation keys must go under the `content` key**, \\notherwise they will not be considered translations.\\n\\nIf you are not familiar with YAML, think of it as JSON without quotes, and remember:\\n\\n```yaml\\ncontent:\\n  loading: Loading...\\n  done: Done :)\\n```\\n\\nIs different from the code below. (Basically intention is super important)\\n\\n```yaml\\ncontent:\\n  loading: Loading...\\n  done: Done :)\\n```\\n\\nSo far, this was all the necessary steps we needed to take for translating our app.\\n\\n## Step 6: Use and config fireback language generator\\n\\nNow we need to use the Fireback language generator to simplify key generation for us.\\n\\n```bash\\nfireback gen strings --path ./src/strings/strings-en.yml --langs pl,fa\\n```\\n\\nThis command will generate two additional files in the same directory:\\n`strings-pl.yml` and `strings-fa.yml`. If you open them, you will see identical \\ncontent to your `strings-en.yml`.\\n\\nAlso in the same directory, you will find a `translations.ts` file. \\nIt contains content similar to the snippet below, which has generated TypeScript \\nconstants for all three languages and exported them as `strings`.\\n\\n## Step 7: Make this automated with VSCode run-on-save\\n\\nUsing the CLI each time for building the translations is cumbersome. Therefore, we utilize the \\"Run on save\\" extension in VSCode, which you can install.\\n\\nThen, in our `settings.json` in VSCode, we need to add these rules. \\n(If you\'ve never modified this file, create a folder named `.vscode` at the root \\nof your project and add `settings.json` inside it.)\\n\\n```json\\n{\\n  // other configuration before\\n\\n  \\"emeraldwalk.runonsave\\": {\\n    \\"commands\\": [\\n      {\\n        \\"match\\": \\"strings-([a-z][a-z]).yml$\\",\\n        \\"cmd\\": \\"fireback gen strings --path ${file} --langs en,fa\\"\\n      }\\n    ]\\n  }\\n\\n  // other configuration after\\n}\\n```\\n\\nIt would basically detect any `strings-xx.yml` change in the project, and will run strings\\ncompiler for you.\\n\\n## Step 8: Use translations\\n\\nAt this stage, the tarnslation dictionary has been created fully, and we can\\nuse them by `useS` and access the keys on the `s` object. It\'s good to keep\\nthe names consistent across the entire project to make it clean.\\n\\n**React.js**:\\n```tsx\\nimport { strings } from \\"./strings/translations\\";\\nexport function MyComponent() {\\n  const s = useS(strings)\\n\\n  return <p>{s.loading}</p>\\n}\\n```\\n**React Native**:\\n```tsx\\nimport { Text } from \'react-native\';\\nimport { strings } from \\"./strings/translations\\";\\nexport function MyComponent() {\\n  const s = useS(strings)\\n\\n  return <Text>{s.loading}</Text>\\n}\\n```\\n\\n## Conclusion\\n\\nTo summarize, we have just created a robust system for adding translations to our react or react native app.\\nThis method will help prevent many errors, such as missing keys in certain \\nlanguages and hard-coded strings for translation.\\n\\nThe Fireback Strings CLI offers additional options that you may want to explore on your own. \\nThis feature is available starting from Fireback v1.1.9"},{"id":"/top-reasons-software-teams-and-companies-suffer-from-their-own-decisions","metadata":{"permalink":"/blog/top-reasons-software-teams-and-companies-suffer-from-their-own-decisions","editUrl":"https://github.com/torabian/torabian.github.io/tree/main/packages/create-docusaurus/templates/shared/blog/top-reasons-software-teams-and-companies-suffer-from-their-own-decisions.mdx","source":"@site/blog/top-reasons-software-teams-and-companies-suffer-from-their-own-decisions.mdx","title":"Top reasons software teams and companies suffer from their own decisions","description":"When I join a company and I see managers complaining, coders complaining and designer complaining, I see a quite common","date":"2025-10-13T20:32:31.000Z","tags":[],"readingTime":3.19,"hasTruncateMarker":false,"authors":[],"frontMatter":{"title":"Top reasons software teams and companies suffer from their own decisions","excerpt":"When I join a company and I see managers complaining, coders complaining and designer complaining, I see a quite common pattern which I tried to not them happen in PixePlux projects and clients.","lang":"en"},"unlisted":false,"prevItem":{"title":"Stop Chaos! React & React Native Translations Done Right Once","permalink":"/blog/stop-chaos-react-and-react-native-translations-done-right"},"nextItem":{"title":"Why to use lottie in React Native mobile development","permalink":"/blog/why-use-lottie-in-react-native-mobile-development"}},"content":"When I join a company and I see managers complaining, coders complaining and designer complaining, I see a quite common\\npattern which I tried to not them happen in PixePlux projects and clients.\\n\\n## Use only MySQL or SQLite\\n\\nVery often, people get into trouble by just using something weird, such as Postgres, Mongodb, Firebase, or 100 more\\ndatabase brands out there. In fact, MySQL or SQLite are capable of serving up to 99% of projects, up to facebook level\\ndata (MySQL). Spend a bit of time designing the right database, make two version of app which works both with\\nSQLite and MySQL - using any orm this is just a config change - and never do not fall into hoax of some amazing database\\nfor a project which never gonna have more than 100 GB of database in decade.\\n\\n## They care about code more than product\\n\\nWe all read books about how to write \\"Clean code\\", so we did read \\"How to became milioner\\". The only important perspective\\nof a software product is how users see that, not how or in which language it\'s written on.\\n\\nProgrammers usually do not care of software result, they are into topics which language it\'s used, which framework, which plugin,\\nthings which are only important to them, or maybe their tech leader.\\n\\nProgrammers should do their trial and error and lalaland task in codepen, github personal account, and do not bring any new library,\\ncode style, linting, plugin into the production. I see so often the entire project is stuck in how to use Redux clearly,\\nand the project which code have 10 screens in 1 week, has gone nowhere in 3 months.\\n\\n## They produce large size or slow applications\\n\\nUsing wrong tools, you end up having software which consumes more resources than it should, this results in many issues.\\n\\n- They need very good computer to write code, run the project.\\n- The application will end up large source and many users loose patience to download - specially if it\'s not so critical.\\n- They can\'t ship easily, sign the app.\\n\\nAn example is projects written in Angular (Web) framework. The bundle size is that much big and rendering is so slow\\nthat every project feels so slow and laggy, not only it ends in user frustration, but also the developers themselves\\nfeel tired looking each time they want change something it takes couple of seconds and they want to start a new project.\\n\\n## There is no documentation or explanation of software\\n\\nMany backends, front-ends, are being created without any explanation. Even a new developer in the same team needs to \\ngo few days into learning curve in order to run the project. Look at all major softwares, Windows, MySQL, Adobe, \\nthey all run without baby sitting from their vendors.\\n\\n## They are not using proper programming language\\n\\nI did so much of research, and somehow ended up any project which lasted for decades, it\'s written in C/C++\\nit\'s no suprise, anything written in scripting languages, all the time needs maintaince and will not last 1-2 years even.\\n\\nDue to my personal research these are the only proper tools:\\n\\n- Writting Android apps in Java (Not Hybrid, Ionic, Xamarin,...)\\n- Writing Ios apps in ObjectiveC and Swift.\\n- Writing any backend, system service, desktop application in C++, or in worst case Golang\\n- React for frontend (Not Angular, Ember, Vuejs)\\n\\n## They are using things they do not need.\\n\\nDocker, MariaDB, Fireback storage, Elasticbeans talk, CircleCi, Bitrise, Fastlane, and you name it. It seems to many\\npeople they cannot build anything without 80% of thirdparty services. Worlds most important software is written\\nwhen none of these existed.\\n\\nUsing these tools, adds up a lot of extra time and overhead to deliver a project, which if it was written in C++ or Golang\\nwould end up 10% of the time."},{"id":"/why-use-lottie-in-react-native-mobile-development","metadata":{"permalink":"/blog/why-use-lottie-in-react-native-mobile-development","editUrl":"https://github.com/torabian/torabian.github.io/tree/main/packages/create-docusaurus/templates/shared/blog/why-use-lottie-in-react-native-mobile-development.mdx","source":"@site/blog/why-use-lottie-in-react-native-mobile-development.mdx","title":"Why to use lottie in React Native mobile development","description":"Animations are essential for most of user interfaces. Human being naturally are used to see things change in transition,","date":"2025-10-13T20:32:31.000Z","tags":[],"readingTime":2.05,"hasTruncateMarker":false,"authors":[],"frontMatter":{"title":"Why to use lottie in React Native mobile development","excerpt":"Animations are essential for most of user interfaces. Human being naturally are used to see things change in transition, a leaf is falling down with an speed. No one expecting to see the leaf on the tree, and immediately on the ground.","lang":"en"},"unlisted":false,"prevItem":{"title":"Top reasons software teams and companies suffer from their own decisions","permalink":"/blog/top-reasons-software-teams-and-companies-suffer-from-their-own-decisions"},"nextItem":{"title":"Zatrzymaj Chaos! T\u0142umaczenia Angular Wykonane Jak Trzeba Raz","permalink":"/blog/zatrzymaj-chaos-t\u0142umaczenia-angular-wykonane-poprawnie"}},"content":"import { AnimatedLogo } from \'../components/lottie/Lottie\'\\n\\nAnimations are essential for most of user interfaces. Human being naturally are used to see things change in transition,\\na leaf is falling down with an speed. No one expecting to see the leaf on the tree, and immediately on the ground.\\n\\nFor the very same reason, we build applications in a way that actions are happening in an animation sequence. Creating\\nanimations in dedicated softwares are easy, for example in AfterEffects, you have a time line, keyframes and tons\\nof visual tools to create all kind of custom animations you want, and exporting them as Gif or many different formats.\\n\\n**In programming, creating animation is difficult**, most of the time you are not able to see how the animation works\\nuntil you run it, and you need to work with scripts, and selecting elements then using JavaScript build those sequences, like:\\n\\n```js\\nAnimated.sequence([\\n  // decay, then spring to start and twirl\\n  Animated.decay(position, {\\n    // coast to a stop\\n    velocity: { x: gestureState.vx, y: gestureState.vy }, // velocity from gesture release\\n    deceleration: 0.997\\n  }),\\n  Animated.parallel([\\n    // after decay, in parallel:\\n    Animated.spring(position, {\\n      toValue: { x: 0, y: 0 } // return to start\\n    }),\\n    Animated.timing(twirl, {\\n      // and twirl\\n      toValue: 360\\n    })\\n  ])\\n]).start(); // start the sequence group\\n```\\n\\nAnimating using scripts like this might be only option for some actions, but it has drawbacks such as:\\n\\n* You are limited. It\'s only allowing some parameters of elements to be animated, such as transform, opacity\\n* Only a programmer can adjust these. You loose all talent that UI/UX team has built in years.\\n* It\'s not supporting advanced animations. If you want to create an envelop being closed after user clicking on \\"Send mail\\"\\nbutton, it\'s gonna take hours and hours of work, if even possible after all.\\n\\n## Designing animations in AfterEffects\\n\\nAn alternative to all these problems is to design animations in an advanced tool such as AfterEffecs. Using plugin called lottie,\\nyou can export the 2d motion graphics into a json format, which later allows you to use it in Web, React Native or desktop applications\\n\\nFor example we created PixelPlux logo animated:\\n<AnimatedLogo loop path=\\"/blog/pixelplux_logo.json\\" className=\\"large-animate-preview\\" />\\n\\n<br />\\nOr you can take a look at my design for Github logo:\\n<AnimatedLogo loop path=\\"/blog/github_logo_animated_ali_torabi.json\\" className=\\"large-animate-preview\\" />\\n\\n<br />\\n<br />\\n## Effects on the Mobile Project.\\n\\nUsing Lottie animations, specially well built ones, increases the user experience quality, for tasks such as\\nprocessing a payment, searching for content, giving news bullitens and many more."},{"id":"/zatrzymaj-chaos-t\u0142umaczenia-angular-wykonane-poprawnie","metadata":{"permalink":"/blog/zatrzymaj-chaos-t\u0142umaczenia-angular-wykonane-poprawnie","editUrl":"https://github.com/torabian/torabian.github.io/tree/main/packages/create-docusaurus/templates/shared/blog/zatrzymaj-chaos-t\u0142umaczenia-angular-wykonane-poprawnie.mdx","source":"@site/blog/zatrzymaj-chaos-t\u0142umaczenia-angular-wykonane-poprawnie.mdx","title":"Zatrzymaj Chaos! T\u0142umaczenia Angular Wykonane Jak Trzeba Raz","description":"Krytyczne problemy z ng translate, i18n i innymi","date":"2025-10-13T20:32:31.000Z","tags":[],"readingTime":5.66,"hasTruncateMarker":false,"authors":[{"name":"Ali Torabi","key":null,"page":null}],"frontMatter":{"title":"Zatrzymaj Chaos! T\u0142umaczenia Angular Wykonane Jak Trzeba Raz","author":"Ali Torabi","excerpt":"Masz problemy z t\u0142umaczeniem aplikacji Angular? Czy zawsze pojawiaj\u0105 si\u0119 k\u0142opoty z kluczami, dodatkowymi rurkami czy te\u017c statycznymi t\u0142umaczeniami? Do\u0142\u0105cz do mnie w tej tutoriale, a raz na zawsze rozwi\u0105\u017cemy ten problem.","og_image":"/content/angular_translate_logo.png","lang":"pl"},"unlisted":false,"prevItem":{"title":"Why to use lottie in React Native mobile development","permalink":"/blog/why-use-lottie-in-react-native-mobile-development"}},"content":"## Krytyczne problemy z ng translate, i18n i innymi\\n\\nZnaczenie t\u0142umacze\u0144 wydaje si\u0119 by\u0107 pomijane, a drugi j\u0119zyk cz\u0119sto traktowany jest po macoszemu w moich projektach; niekt\xf3re z nich nawet zaczynaj\u0105 si\u0119 od niew\u0142a\u015bciwych ci\u0105g\xf3w znak\xf3w w szablonach, aby p\xf3\u017aniej napotka\u0107 trudno\u015bci przy pr\xf3bie ich modyfikacji, poniewa\u017c brak bezpiecze\u0144stwa typ\xf3w uniemo\u017cliwia natychmiastowe wykrycie wszystkich wyst\u0105pie\u0144, co prowadzi do niejednolitego do\u015bwiadczenia u\u017cytkownika, gdzie angielskie s\u0142owa mog\u0105 niespodziewanie pojawi\u0107 si\u0119 w hiszpa\u0144skim interfejsie, co negatywnie wp\u0142ywa na reputacj\u0119 marki.\\n\\nModu\u0142 ng translate, cho\u0107 pocz\u0105tkowo wygodne narz\u0119dzie do obs\u0142ugi t\u0142umacze\u0144 w aplikacjach Angular, cz\u0119sto zawodzi w kilku kluczowych obszarach. Jednym z powszechnych problem\xf3w jest obecno\u015b\u0107 statycznych ci\u0105g\xf3w znak\xf3w w szablonach, co sprawia, \u017ce utrzymanie i aktualizacja t\u0142umacze\u0144 staje si\u0119 wyzwaniem. Dodatkowo, brak wsparcia IntelliSense ogranicza produktywno\u015b\u0107 deweloper\xf3w, prowadz\u0105c do potencjalnych b\u0142\u0119d\xf3w i niekonsekwencji w t\u0142umaczeniach. Ponadto, ograniczone mo\u017cliwo\u015bci modu\u0142u w zarz\u0105dzaniu r\xf3\u017cnymi j\u0119zykami skutkuj\u0105 k\u0142opotliwymi procesami i trudno\u015bciami w utrzymaniu tre\u015bci zwi\u0105zanych z j\u0119zykiem.\\n\\nInnym istotnym problemem jest k\u0142opotliwy proces przechowywania t\u0142umacze\u0144 w oddzielnych plikach JSON, co mo\u017ce prowadzi\u0107 do zagraconych struktur projektu i problem\xf3w z kontrol\u0105 wersji. Te wyzwania wsp\xf3lnie przyczyniaj\u0105 si\u0119 do niedostatecznego do\u015bwiadczenia zwi\u0105zanego z t\u0142umaczeniami, zmuszaj\u0105c deweloper\xf3w do poszukiwania alternatywnych rozwi\u0105za\u0144 dla swoich potrzeb lokalizacyjnych.\\n\\n## Rozwi\u0105zanie jest proste; I nie potrzeba biblioteki\\n\\nW rzeczywisto\u015bci, stworzenie niezawodnego mechanizmu t\u0142umaczenia dla projekt\xf3w Angular nie wymaga dodatkowej biblioteki. W tym samouczku rozwi\u0105\u017cemy ten problem za pomoc\u0105 dw\xf3ch element\xf3w:\\n\\n- Komponentu podstawowego dla wszystkich komponent\xf3w w aplikacji\\n- Us\u0142ugi LocaleService, kt\xf3ra b\u0119dzie obs\u0142ugiwa\u0107 zmiany j\u0119zyka i publikowa\u0107 je wsz\u0119dzie\\n\\n## Co potrzebujesz wcze\u015bniej\\n\\n**Mo\u017cesz zastosowa\u0107 to, czego si\u0119 nauczysz tutaj do nowych projekt\xf3w, a tak\u017ce do istniej\u0105cego projektu**\\n\\n- Aby nad\u0105\u017cy\u0107 za szkoleniem, potrzebujesz pustego projektu angular 2+.\\n  U\u017cywam tutaj najnowszej wersji, kt\xf3ra ma \'samodzielne\' komponenty, ale je\u015bli korzystasz\\n  z starszej wersji Angular, nie b\u0119dzie to mia\u0142o znaczenia.\\n\\n- Zainstaluj fireback v1.1.9 lub nowsz\u0105 wersj\u0119. Installers dla r\xf3\u017cnych system\xf3w mo\u017cna znale\u017a\u0107 tutaj:\\n  <a href=\\"https://github.com/torabian/fireback/releases\\" target=\\"_blank\\">https://github.com/torabian/fireback/releases</a>\\n\\n- Korzystam z VSCode, a rozszerzenie Run On Save jest w\u0142\u0105czone. Mo\u017cesz uruchamia\u0107 t\u0142umaczenie\\n  r\xf3wnie\u017c z wiersza polece\u0144, ale posiadanie tego rozszerzenia znacznie u\u0142atwia \u017cycie.\\n\\n## Krok 1: Sprawd\u017a, czy masz dost\u0119p do fireback\\n\\nMusisz upewni\u0107 si\u0119, \u017ce masz dost\u0119p do binari\xf3w fireback, czy to zainstalowanych globalnie,\\nczy te\u017c umieszczonych w katalogu projektu i zignorowanych.\\n\\n## Krok 2: Stw\xf3rz us\u0142ug\u0119 LocaleService\\n\\nOto przekszta\u0142cona wersja:\\n\\nUs\u0142uga `LocaleService` jest prost\u0105 us\u0142ug\u0105, kt\xf3ra b\u0119dzie u\u017cywana niemal wsz\u0119dzie w projekcie,\\nz jednym celem: przechowywa\u0107 i synchronizowa\u0107 dane dotycz\u0105ce lokalizacji.\\n\\nW tej us\u0142udze istnieje obserwowalna o nazwie `locale$`, kt\xf3r\u0105 b\u0119dziemy subskrybowa\u0107 w\\nkomponencie, aby zmieni\u0107 s\u0142ownik zmiennych t\u0142umacze\u0144. Dodatkowo, jest funkcja `setLocale`,\\nkt\xf3ra ustawia j\u0119zyk. Na przyk\u0142ad, `setLocale(\'en\')` zmieni j\u0119zyk na angielski.\\n\\n```ts\\nimport { Injectable } from \'@angular/core\';\\nimport { BehaviorSubject } from \'rxjs\';\\n\\n@Injectable({\\n  providedIn: \'root\',\\n})\\nexport class LocaleService {\\n  private localeSubject = new BehaviorSubject<string>(\'en\');\\n  locale$ = this.localeSubject.asObservable();\\n\\n  constructor() {}\\n\\n  setLocale(locale: string) {\\n    this.localeSubject.next(locale);\\n  }\\n}\\n```\\n\\n## Krok 3: Stw\xf3rz komponent bazowy\\n\\nStworzenie komponentu bazowego to pot\u0119\u017cna funkcja Angulara i TypeScriptu,\\nkt\xf3ra u\u0142atwia rozszerzanie niekt\xf3rych podstawowych funkcji dla ka\u017cdego komponentu w projekcie.\\nJe\u015bli ju\u017c masz taki komponent w projekcie, mo\u017cesz zastosowa\u0107 tutaj kod do niego.\\nJe\u015bli zaczynasz od nowa, utw\xf3rz nowy komponent o nazwie `base.component.ts`.\\n\\n**Wa\u017cne:** Musisz u\u017cy\u0107 dekoratora `@Directive` zamiast `@Component`; w przeciwnym razie,\\nAngular nie b\u0119dzie go kompilowa\u0107.\\n\\nPo pierwsze, potrzebujemy zmiennej, na przyk\u0142ad `s`, aby przechowywa\u0107 kluczowe t\u0142umaczenia dla szablonu\\nlub komponentu. B\u0119dzie ona `chroniona`, aby klasy rozszerzaj\u0105\\n\\nce faktycznie mia\u0142y do niej dost\u0119p,\\njak r\xf3wnie\u017c do pliku szablonu.\\n\\nNast\u0119pnie musimy wstrzykn\u0105\u0107 `LocaleService` oraz obiekt klucz\xf3w t\u0142umacze\u0144 podczas konstrukcji.\\nTen obiekt b\u0119dzie przechowywa\u0142 t\u0142umaczenia dla wszystkich j\u0119zyk\xf3w (jak zobaczysz p\xf3\u017aniej, po wygenerowaniu\\npliku `translations.ts`). W konstruktorze b\u0119dziemy wywo\u0142ywa\u0107 funkcj\u0119 `handleLocale`,\\nkt\xf3ra jest po prostu subskrypcj\u0105 do lokalizacji i zast\u0105pi s\u0142ownik zawarto\u015bci `s`\\nwybranym j\u0119zykiem.\\n\\n## Krok 4: Stw\xf3rz folder \'strings\'\\n\\nJak zorganizujesz t\u0142umaczenia, zale\u017cy od Ciebie. Ja preferuj\u0119 tworzenie folderu `strings`\\ndla ka\u017cdego modu\u0142u i umieszczanie wszystkich ich t\u0142umacze\u0144 w tym katalogu.\\nW ten spos\xf3b, gdy przenios\u0119 folder modu\u0142u do innego projektu lub chc\u0119 go uczyni\u0107 bibliotek\u0105,\\nnie b\u0119d\u0119 musia\u0142 martwi\u0107 si\u0119 o t\u0142umaczenia; ju\u017c s\u0105 rozwi\u0105zane i do\u0142\u0105czone do komponentu\\nlub modu\u0142u.\\n\\nZ drugiej strony, je\u015bli chcesz utworzy\u0107 folder `strings` dla ca\u0142ej aplikacji, nic Ci\u0119 nie zatrzyma.\\n\\n## Krok 5: Stw\xf3rz plik strings/strings-en.yml\\n\\nKrytyczne jest pami\u0119tanie, \u017ce modu\u0142 Fireback Language Editor zak\u0142ada angielski\\njako g\u0142\xf3wny j\u0119zyk aplikacji. Innymi s\u0142owy, angielski musi by\u0107 obecny, a inne j\u0119zyki\\nb\u0119d\u0105 synchronizowane z kluczami z tego.\\n\\nTeraz umie\u015b\u0107my `tre\u015b\u0107` wewn\u0105trz YAML.\\n**Wszystkie klucze t\u0142umacze\u0144 musz\u0105 by\u0107 umieszczone pod kluczem `content`**,\\nw przeciwnym razie nie zostan\u0105 one uznane za t\u0142umaczenia.\\n\\nJe\u015bli nie jeste\u015b zaznajomiony z YAML, my\u015bl o nim jak o JSON bez cudzys\u0142ow\xf3w, i pami\u0119taj:\\n\\n```yaml\\ncontent:\\n  loading: Loading\\n  done: Ready :)\\n```\\n\\nJest r\xf3\u017cny od kodu poni\u017cej. (Podstawowa r\xf3\u017cnica to wci\u0119cia).\\n\\n```yaml\\ncontent:\\nloading: \u0141adowanie...\\n  done: Gotowe :)\\n```\\n\\nDo tej pory to wszystkie niezb\u0119dne kroki, kt\xf3re musieli\u015bmy podj\u0105\u0107, aby przet\u0142umaczy\u0107 nasz\u0105 aplikacj\u0119.\\n\\n## Krok 6: U\u017cyj i skonfiguruj generator j\u0119zyka fireback\\n\\nTeraz musimy u\u017cy\u0107 generatora j\u0119zyka Fireback do uproszczenia generowania kluczy dla nas.\\n\\n```bash\\nfireback gen strings --path ./src/app/components/loader-sample/strings/strings-en.yml --targets ts --langs pl,fa\\n```\\n\\nTo polecenie wygeneruje dwa dodatkowe pliki w tym samym katalogu:\\n`strings-pl.yml` i `strings-fa.yml`. Je\u015bli je otworzysz, zobaczysz identyczn\u0105\\ntre\u015b\u0107 jak w twoim `strings-en.yml`.\\n\\nR\xf3wnie\u017c w tym samym katalogu znajdziesz plik `translations.ts`.\\nZawiera on tre\u015b\u0107 podobn\u0105 do fragmentu poni\u017cej, kt\xf3ry wygenerowa\u0142 sta\u0142e TypeScript\\ndla wszystkich trzech j\u0119zyk\xf3w i wyeksportowa\u0142 je jako `strings`.\\n\\n## Krok 7: Zautomatyzuj to za pomoc\u0105 VSCode run-on-save\\n\\nU\u017cywanie CLI za ka\u017cdym razem do budowania t\u0142umacze\u0144 jest k\u0142opotliwe. Dlatego korzystamy z rozszerzenia \\"Run on save\\" w VSCode, kt\xf3re mo\u017cesz zainstalowa\u0107.\\n\\nNast\u0119pnie w pliku `settings.json` w VSCode musimy doda\u0107 te regu\u0142y.\\n(Je\u015bli nigdy nie modyfikowa\u0142e\u015b tego pliku, utw\xf3rz folder o nazwie `.vscode` w g\u0142\xf3wnym katalogu\\ntwojego projektu i dodaj w nim plik `settings.json`.)\\n\\n```\\n{\\n    \\"emeraldwalk.runonsave\\": {\\n        \\"commands\\": [\\n            {\\n                \\"match\\": \\"strings-([a-z][a-z]).yml$\\",\\n                \\"cmd\\": \\"fireback gen strings --path ${file} --langs en,fa\\"\\n            }\\n        ]\\n    }\\n}\\n```\\n\\nTo w zasadzie wykryje ka\u017cd\u0105 zmian\u0119 `strings-xx.yml` w projekcie i uruchomi dla ciebie kompilator ci\u0105g\xf3w.\\n\\n## Krok 8: U\u017cyj t\u0142umacze\u0144\\n\\nW tej fazie, jeste\u015bmy praktycznie gotowi do wykorzystania pliku t\u0142umacze\u0144.\\nW ka\u017cdym komponencie, kt\xf3ry rozszerza `BaseComponent`, b\u0119dziesz m\xf3g\u0142 przekaza\u0107 `strings` i\\nuzyska\u0107 dost\u0119p do zmiennej `s` zar\xf3wno wewn\u0105trz komponentu, jak i w szablonie.\\n\\n\\n```ts\\nimport { Component } from \'@angular/core\';\\nimport { BaseComponent } from \'../base.component\';\\nimport { LocaleService } from \'../../locale.service\';\\nimport { strings } from \'./strings/translations\';\\n\\n@Component({\\n  selector: \'app-loader-sample\',\\n  standalone: true,\\n  imports: [],\\n  templateUrl: \'./loader-sample.component.html\',\\n  styleUrl: \'./loader-sample.component.scss\',\\n})\\nexport class LoaderSampleComponent extends BaseComponent {\\n  override s = strings;\\n  constructor(private locale: LocaleService) {\\n    super(locale, strings);\\n  }\\n}\\n```\\n\\nI mo\u017cesz uzyska\u0107 dost\u0119p do `s` i wszystkich kluczy bezpiecznie w szablonach HTML. *Jak zauwa\u017cy\u0142e\u015b*,\\nfaktycznie nie musimy u\u017cywa\u0107 rurki do t\u0142umacze\u0144 w og\xf3le, co stanowi znacz\u0105c\u0105 korzy\u015b\u0107\\nzar\xf3wno pod wzgl\u0119dem wydajno\u015bci, jak i czysto\u015bci kodu.\\n\\n```html\\n<p>{{ s.loading }}</p>\\n```\\n## Podsumowanie\\n\\nPodsumowuj\u0105c, w\u0142a\u015bnie stworzyli\u015bmy solidny system dodawania t\u0142umacze\u0144 do naszej aplikacji Angular.\\nTa metoda pomo\u017ce unikn\u0105\u0107 wielu b\u0142\u0119d\xf3w, takich jak brakuj\u0105ce klucze w niekt\xf3rych\\nj\u0119zykach i twardo zakodowane ci\u0105gi dla t\u0142umaczenia."}]}}')}}]);